<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Breach Protocol (JS) — V4-Beta</title>
  <style>
    html, body {
      height:100%;
      margin:0;
      background:#07090f;
      color:#dce6f5;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      overflow:hidden;
    }
    #wrap { height:100%; }
    canvas { display:block; width:100%; height:100%; }

    /* Bouton audio discret */
    #btnSound{
      position:fixed; left:16px; bottom:16px; z-index:10;
      padding:10px 12px; border-radius:12px;
      border:1px solid rgba(0,255,160,.35);
      background:rgba(16,20,28,.80);
      color:#dce6f5; cursor:pointer;
      backdrop-filter: blur(6px);
      box-shadow: 0 0 18px rgba(0,255,160,.10);
      user-select:none;
    }
    #btnSound:hover{ border-color: rgba(0,255,160,.65); }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>
</div>

<button id="btnSound">Activer le son</button>

<!-- ===================== AUDIO ===================== -->
<audio id="musicMenu" loop preload="auto">
  <source src="audio/menu.mp3" type="audio/mpeg">
</audio>
<audio id="musicGame" loop preload="auto">
  <source src="audio/game.mp3" type="audio/mpeg">
</audio>
<audio id="sfxSuccess" preload="auto">
  <source src="audio/success.mp3" type="audio/mpeg">
</audio>
<audio id="sfxFail" preload="auto">
  <source src="audio/fail.mp3" type="audio/mpeg">
</audio>

<!-- NEW: click/button SFX -->
<audio id="sfxClick" preload="auto">
  <source src="audio/click.mp3" type="audio/mpeg">
</audio>

<script>
(() => {
  // =========================================================
  // CONFIG / THEME
  // =========================================================
  const TOKENS = ["BD","55","1C","E9","7A","FF","0A","9C","DA","6B","2E","F1"];
  const FPS = 60;

  // Optional animated menu background (images)
  // Put files in /bg/ : menu_0001.jpg ... menu_0012.jpg
  const MENU_BG_ENABLED = true;
  const MENU_BG_FRAMES = 12; // change if needed
  const MENU_BG_FPS = 6;     // animation speed

  const COL = {
    bg0: [7,9,15],
    bg1: [10,12,20],
    panel: [18,22,30],
    panel2: [14,18,26],
    text: [220,230,245],
    dim: [130,145,170],
    green: [0,255,160],
    cyan: [0,200,255],
    yellow: [255,220,80],
    magenta: [220,120,255],
    red: [255,90,90],
    cell: [26,32,44],
    cellBorder: [50,60,80],

    pathRed: [255,80,80],
    pathBlue: [80,140,255],
    pathGreen: [0,255,160],
    extras: [
      [255,220,80],
      [220,120,255],
      [0,200,255],
      [255,140,0],
      [140,255,140]
    ]
  };

  const SCEN_LABELS = [
    "Choix : Puzzle 1 ou Puzzle 2",
    "Puzzle 1 + Puzzle 2 possible",
    "Priorité Puzzle 2 (Puzzle 2 sans Puzzle 1 possible)",
  ];

  const BONUS_LABELS = {
    none: "Aucun",
    bonus: "Bonus (+2s par sélection)",
    malus: "Malus (-2s par sélection)"
  };

  const BONUS_TIME_DELTA = { none: 0, bonus: +2, malus: -2 };

  // =========================================================
  // PRNG (seeded) — Mulberry32
  // =========================================================
  function xmur3(str) {
    let h = 1779033703 ^ str.length;
    for (let i = 0; i < str.length; i++) {
      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      h = (h << 13) | (h >>> 19);
    }
    return function() {
      h = Math.imul(h ^ (h >>> 16), 2246822507);
      h = Math.imul(h ^ (h >>> 13), 3266489909);
      h ^= h >>> 16;
      return h >>> 0;
    };
  }
  function mulberry32(a) {
    return function() {
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  function makeRngFromSeedString(seedStr) {
    const seedFn = xmur3(seedStr);
    return mulberry32(seedFn());
  }
  function randInt(rng, min, max) {
    return Math.floor(rng() * (max - min + 1)) + min;
  }
  function choice(rng, arr) {
    return arr[Math.floor(rng() * arr.length)];
  }

  // =========================================================
  // SEED PACKING (simple, partageable)
  // =========================================================
  // Seed = base64url(JSON)
  function b64urlEncode(str) {
    return btoa(unescape(encodeURIComponent(str)))
      .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }
  function b64urlDecode(str) {
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    while (str.length % 4) str += "=";
    return decodeURIComponent(escape(atob(str)));
  }

  // v2 -> still "BP2." but we add undoAllowed (backward compatible)
  function makeSeedPayload({ seedText, diff, series, timeLimit, bonusMode, undoAllowed }) {
    return {
      v: 2,
      seedText: seedText || "",
      diff,
      series,
      timeLimit,
      bonusMode,
      undoAllowed
    };
  }

  function encodeSeed(payload) {
    return "BP2." + b64urlEncode(JSON.stringify(payload));
  }

  function decodeSeed(seed) {
    if (!seed || typeof seed !== "string") return null;
    if (!seed.startsWith("BP2.")) return null;
    try {
      const json = b64urlDecode(seed.slice(4));
      const obj = JSON.parse(json);
      if (!obj || obj.v !== 2) return null;
      return obj;
    } catch {
      return null;
    }
  }

  function randomSeedText() {
    const alphabet = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    let s = "";
    for (let i=0;i<10;i++) s += alphabet[Math.floor(Math.random()*alphabet.length)];
    return s;
  }

  // =========================================================
  // AUDIO (autoplay-safe)
  // =========================================================
  const musicMenu = document.getElementById("musicMenu");
  const musicGame = document.getElementById("musicGame");
  const sfxSuccess = document.getElementById("sfxSuccess");
  const sfxFail = document.getElementById("sfxFail");
  const sfxClick = document.getElementById("sfxClick");
  const btnSound = document.getElementById("btnSound");

  musicMenu.volume = 0.35;
  musicGame.volume = 0.35;
  sfxSuccess.volume = 0.85;
  sfxFail.volume = 0.85;
  sfxClick.volume = 0.60;

  let audioUnlocked = false;
  let currentMusic = null;

  function safePlay(el){
    if(!audioUnlocked) return;
    const p = el.play();
    if(p && p.catch) p.catch(()=>{});
  }
  function safePause(el){ el.pause(); }

  function setMusic(next){
    if(currentMusic === next) return;
    if(currentMusic) safePause(currentMusic);
    currentMusic = next;
    if(currentMusic) safePlay(currentMusic);
  }

  function playSfx(el){
    if(!audioUnlocked) return;
    try { el.currentTime = 0; } catch {}
    safePlay(el);
  }

  // Click anti-spam
  let lastClickSfxAt = 0;
  function playClick(){
    if(!audioUnlocked) return;
    const t = performance.now();
    if (t - lastClickSfxAt < 45) return;
    lastClickSfxAt = t;
    playSfx(sfxClick);
  }

  function unlockAudioOnce(){
    if(audioUnlocked) return;
    audioUnlocked = true;
    btnSound.textContent = "Son activé";
    syncMusicToState();
  }

  btnSound.addEventListener("click", unlockAudioOnce);
  window.addEventListener("pointerdown", unlockAudioOnce, { once:true });
  window.addEventListener("keydown", unlockAudioOnce, { once:true });

  // =========================================================
  // CANVAS
  // =========================================================
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  function rgb(a){ return `rgb(${a[0]},${a[1]},${a[2]})`; }
  function rgba(a, alpha){ return `rgba(${a[0]},${a[1]},${a[2]},${alpha})`; }
  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  // =========================================================
  // OPTIONAL: animated menu background frames
  // =========================================================
  const menuBg = [];
  let menuBgReady = false;
  if (MENU_BG_ENABLED) {
    for (let i=1;i<=MENU_BG_FRAMES;i++){
      const img = new Image();
      img.src = `bg/menu-${String(i).padStart(4,"0")}.jpg`;
      img.onload = () => {
        if(menuBg.filter(x=>x.complete).length === MENU_BG_FRAMES) menuBgReady = true;
      };
      img.onerror = () => {
        // if missing frames, we simply disable
        menuBgReady = false;
      };
      menuBg.push(img);
    }
  }

  // =========================================================
  // GAME LOGIC
  // =========================================================
  function settingsFromDifficulty(d){
    d = clamp(d, 5, 15);
    const grid = d;
    const buffer = clamp(4 + Math.floor((d-5)/2), 4, 10);
    const extraPaths = clamp(Math.floor((d-7)/2), 0, COL.extras.length);
    return { d, grid, buffer, extraPaths };
  }

  function genGrid(rng, n){
    const g = [];
    for(let r=0;r<n;r++){
      const row=[];
      for(let c=0;c<n;c++) row.push(choice(rng, TOKENS));
      g.push(row);
    }
    return g;
  }

  function allowedMoves(n, step, last){
    if(step===0){
      const a=[];
      for(let c=0;c<n;c++) a.push([0,c]);
      return a;
    }
    const [r,c]=last;
    const a=[];
    if(step%2===1){
      for(let rr=0;rr<n;rr++) a.push([rr,c]);
    }else{
      for(let cc=0;cc<n;cc++) a.push([r,cc]);
    }
    return a;
  }

  function bufferContains(buffer, seq){
    if(seq.length>buffer.length) return false;
    for(let i=0;i<=buffer.length-seq.length;i++){
      let ok=true;
      for(let j=0;j<seq.length;j++){
        if(buffer[i+j]!==seq[j]){ ok=false; break; }
      }
      if(ok) return true;
    }
    return false;
  }

  function scoreAndDone(buffer, puzzles){
    let score=0;
    const done=[];
    puzzles.forEach((seq,i)=>{
      if(bufferContains(buffer,seq)){
        done.push(i);
        score += 100*seq.length;
      }
    });
    return {score, done};
  }

  function generateValidPath(rng, n, length){
    const used = new Set();
    const path=[];
    let r=0, c=randInt(rng, 0, n-1);
    path.push([r,c]); used.add(r+","+c);

    for(let step=1; step<length; step++){
      let candidates=[];
      if(step%2===1){
        const col = path[path.length-1][1];
        for(let rr=0; rr<n; rr++) candidates.push([rr,col]);
      }else{
        const row = path[path.length-1][0];
        for(let cc=0; cc<n; cc++) candidates.push([row,cc]);
      }
      const unused = candidates.filter(p=>!used.has(p[0]+","+p[1]));
      const pickFrom = unused.length?unused:candidates;
      const nxt = pickFrom[Math.floor(rng() * pickFrom.length)];
      path.push(nxt);
      used.add(nxt[0]+","+nxt[1]);
    }
    return path;
  }

  function tokensOnPath(grid, path){
    return path.map(([r,c])=>grid[r][c]);
  }

  function makePuzzleFromTokens(rng, tokens, minLen=3, maxLen=6){
    const L=tokens.length;
    maxLen = Math.min(maxLen, L);
    minLen = Math.min(minLen, maxLen);
    const len = randInt(rng, minLen, maxLen);
    const start = randInt(rng, 0, L - len);
    return tokens.slice(start,start+len);
  }

  function generateScenario(rng, grid, s){
    const n=s.grid, buf=s.buffer;
    const scenarioId = [0,1,2][randInt(rng,0,2)];
    const paths = {};

    const p1 = generateValidPath(rng, n, buf);
    const p2 = generateValidPath(rng, n, buf);
    const t1 = tokensOnPath(grid, p1);
    const t2 = tokensOnPath(grid, p2);

    let puzzle1 = makePuzzleFromTokens(rng, t1, 3, Math.min(6,buf));
    let puzzle2 = makePuzzleFromTokens(rng, t2, 3, Math.min(6,buf));

    paths.P1 = p1;
    paths.P2 = p2;

    if(scenarioId===1){
      const p12 = generateValidPath(rng, n, buf);
      const t12 = tokensOnPath(grid, p12);
      puzzle1 = makePuzzleFromTokens(rng, t12, 3, Math.min(6,buf));
      puzzle2 = makePuzzleFromTokens(rng, t12, 3, Math.min(6,buf));
      for(let k=0;k<8;k++){
        if(puzzle2.join(",")!==puzzle1.join(",")) break;
        puzzle2 = makePuzzleFromTokens(rng, t12, 3, Math.min(6,buf));
      }
      paths.P12 = p12;
    }

    if(scenarioId===2){
      const p2only = generateValidPath(rng, n, buf);
      const t2only = tokensOnPath(grid, p2only);
      const len2 = clamp(puzzle2.length, 3, Math.min(6,buf));
      puzzle2 = t2only.slice(0, len2);
      paths.P2ONLY = p2only;
    }

    for(let i=0;i<s.extraPaths;i++){
      paths["EXTRA"+(i+1)] = generateValidPath(rng, n, buf);
    }

    return { puzzles:[puzzle1,puzzle2], paths, scenarioId };
  }

  // =========================================================
  // LAYOUT
  // =========================================================
  function computeLayout(w,h,n){
    const pad=16, top=90, bottom=16;
    const rightW = clamp(Math.floor(w*0.36), 340, 560);
    const gridPanel = {x:pad,y:top,w:w-rightW-3*pad,h:h-top-bottom};
    const rightPanel = {x:gridPanel.x+gridPanel.w+pad,y:top,w:rightW,h:gridPanel.h};
    const inner=16, header=112, gap=6;

    const availW = gridPanel.w-2*inner;
    const availH = gridPanel.h-2*inner-header;

    const cellW = Math.floor((availW-(n-1)*gap)/n);
    const cellH = Math.floor((availH-(n-1)*gap)/n);
    const cell = clamp(Math.min(cellW,cellH), 18, 72);

    const origin = {x:gridPanel.x+inner,y:gridPanel.y+inner+header};
    return {gridPanel,rightPanel,cell,gap,origin,inner,header};
  }

  function cellRect(origin, cell, gap, r,c){
    return {x:origin.x + c*(cell+gap), y:origin.y + r*(cell+gap), w:cell, h:cell};
  }

  function hitCell(mx,my,n,origin,cell,gap){
    const stride = cell+gap;
    const c = Math.floor((mx-origin.x)/stride);
    const r = Math.floor((my-origin.y)/stride);
    if(r<0||c<0||r>=n||c>=n) return null;
    const rect = cellRect(origin,cell,gap,r,c);
    if(mx>=rect.x && mx<=rect.x+rect.w && my>=rect.y && my<=rect.y+rect.h) return [r,c];
    return null;
  }

  // =========================================================
  // UI HELPERS (cyberpunk skin)
  // =========================================================
  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
  }

  function neonText(text, x, y, color, size=34, align="left"){
    ctx.save();
    ctx.font = `700 ${size}px Consolas, monospace`;
    ctx.textAlign = align;
    ctx.textBaseline = "top";
    ctx.shadowColor = rgba(color, 0.55);
    ctx.shadowBlur = 18;
    ctx.fillStyle = rgb(color);
    ctx.fillText(text, x, y);
    ctx.shadowBlur = 0;
    ctx.fillStyle = rgb(color);
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  function fillPanel(rect, baseColor, accentColor=COL.green){
    const g = ctx.createLinearGradient(rect.x, rect.y, rect.x+rect.w, rect.y+rect.h);
    g.addColorStop(0, `rgba(${baseColor[0]},${baseColor[1]},${baseColor[2]},0.92)`);
    g.addColorStop(1, `rgba(${COL.panel2[0]},${COL.panel2[1]},${COL.panel2[2]},0.92)`);
    ctx.fillStyle = g;
    roundRect(rect.x,rect.y,rect.w,rect.h,18);
    ctx.fill();

    ctx.lineWidth = 2;
    ctx.strokeStyle = `rgba(${accentColor[0]},${accentColor[1]},${accentColor[2]},0.25)`;
    ctx.stroke();

    ctx.lineWidth = 1;
    ctx.strokeStyle = `rgba(255,255,255,0.06)`;
    roundRect(rect.x+3,rect.y+3,rect.w-6,rect.h-6,16);
    ctx.stroke();
  }

  function drawScanlines(w,h){
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = "black";
    for(let y=0;y<h;y+=4){
      ctx.fillRect(0,y,w,1);
    }
    ctx.restore();
  }

  function drawGrain(w,h){
    ctx.save();
    ctx.globalAlpha = 0.05;
    ctx.fillStyle = "white";
    const n = 220;
    for(let i=0;i<n;i++){
      const x = Math.random()*w;
      const y = Math.random()*h;
      ctx.fillRect(x,y,1,1);
    }
    ctx.restore();
  }

  function drawMenuBackgroundFrames(w,h){
    if(!MENU_BG_ENABLED) return;
    if(state !== STATE.MENU) return;
    if(!menuBgReady) return;

    const t = performance.now()/1000;
    const idx = Math.floor(t * MENU_BG_FPS) % MENU_BG_FRAMES;
    const img = menuBg[idx];
    if(!img || !img.complete) return;

    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;
    if(!iw || !ih) return;

    const scale = Math.max(w/iw, h/ih);
    const dw = iw*scale, dh = ih*scale;
    const dx = (w - dw)/2, dy = (h - dh)/2;

    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.drawImage(img, dx, dy, dw, dh);
    ctx.restore();
  }

  // =========================================================
  // STATE / MENU OPTIONS (Seed + Série + Temps + Bonus/Malus + Undo)
  // =========================================================
  const STATE = { MENU:"menu", PLAY:"play", RESULT:"result" };
  let state = STATE.MENU;

  // Options menu
  let optDiff = 8;
  let optSeries = 3;          // nombre de hacks à enchaîner
  let optTimeLimit = 15;      // temps par sélection
  let optBonusMode = "none";  // none|bonus|malus
  let optUndoAllowed = true;  // NEW: retour arrière autorisé ?
  let optSeedText = randomSeedText(); // seed lisible
  let shareSeed = "";         // seed complète à partager (BP2.)

  // Run
  let runIndex = 0;           // hack actuel dans la série
  let runScoreTotal = 0;
  let runSuccessCount = 0;

  // Game per-hack
  let s = settingsFromDifficulty(optDiff);
  let rng = makeRngFromSeedString("init");
  let grid=[], puzzles=[], paths={}, scenarioId=0;
  let buffer=[], chosen=[], cursor=[0,0];
  let stepTimerStart = performance.now()/1000;
  let status = "Menu : configure la session.";
  let showPaths = false; // easter egg
  let lastHackScore = 0;
  let lastHackSuccess = false;

  function effectiveTimeLimit(){
    return clamp(optTimeLimit + (BONUS_TIME_DELTA[optBonusMode] || 0), 3, 60);
  }

  function syncMusicToState(){
    if(!audioUnlocked) return;
    if(state === STATE.MENU) setMusic(musicMenu);
    else if(state === STATE.PLAY) setMusic(musicGame);
    else setMusic(musicMenu);
  }

  function updateShareSeed(){
    const payload = makeSeedPayload({
      seedText: optSeedText,
      diff: optDiff,
      series: optSeries,
      timeLimit: optTimeLimit,
      bonusMode: optBonusMode,
      undoAllowed: optUndoAllowed
    });
    shareSeed = encodeSeed(payload);
  }
  updateShareSeed();

  function applySeedString(seedString){
    const decoded = decodeSeed(seedString);
    if(!decoded) return false;

    optSeedText = decoded.seedText || randomSeedText();
    optDiff = clamp(decoded.diff ?? 8, 5, 15);
    optSeries = clamp(decoded.series ?? 1, 1, 20);
    optTimeLimit = clamp(decoded.timeLimit ?? 15, 3, 60);
    optBonusMode = (decoded.bonusMode in BONUS_LABELS) ? decoded.bonusMode : "none";
    optUndoAllowed = (decoded.undoAllowed ?? true);

    updateShareSeed();
    return true;
  }

  function startRun(){
    updateShareSeed();
    runIndex = 0;
    runScoreTotal = 0;
    runSuccessCount = 0;
    startHackAtIndex(0);
  }

  function startHackAtIndex(i){
    runIndex = i;
    s = settingsFromDifficulty(optDiff);

    // RNG stable : seedText + options + index (inclut undoAllowed)
    const seedForThisHack =
      `BP2|${optSeedText}|d=${optDiff}|series=${optSeries}|t=${optTimeLimit}|bm=${optBonusMode}|undo=${optUndoAllowed?1:0}|i=${i}`;
    rng = makeRngFromSeedString(seedForThisHack);

    grid = genGrid(rng, s.grid);
    const out = generateScenario(rng, grid, s);
    puzzles = out.puzzles;
    paths = out.paths;
    scenarioId = out.scenarioId;

    buffer=[]; chosen=[]; cursor=[0,0];
    stepTimerStart = performance.now()/1000;
    status = "Ligne 1 puis alternance colonne/ligne.";
    lastHackScore = 0;
    lastHackSuccess = false;

    state = STATE.PLAY;
    syncMusicToState();
  }

  function canPick(r,c){
    const step = chosen.length;
    const last = chosen.length ? chosen[chosen.length-1] : null;
    const allowed = allowedMoves(s.grid, step, last);
    return allowed.some(([rr,cc])=>rr===r && cc===c);
  }

  function pick(r,c){
    if(!canPick(r,c)){
      status = "Coup interdit (ligne 1 puis alternance colonne/ligne).";
      return;
    }
    playClick(); // NEW: click SFX on valid selection
    chosen.push([r,c]);
    buffer.push(grid[r][c]);
    stepTimerStart = performance.now()/1000; // reset timer ONLY on selection
    status = "Sélection validée.";

    if(buffer.length >= s.buffer){
      finishHack(false);
    }
  }

  function undo(){
    if(!optUndoAllowed){
      status="Retour arrière désactivé.";
      return;
    }
    if(!chosen.length){
      status="Rien à annuler.";
      return;
    }
    playClick(); // NEW: click SFX on undo
    chosen.pop();
    buffer.pop();
    // IMPORTANT: do NOT reset stepTimerStart (no free time)
    status="Annulation effectuée.";
  }

  function finishHack(timeoutFlag){
    const res = scoreAndDone(buffer, puzzles);
    lastHackScore = res.score;

    const success = (!timeoutFlag && res.done.length > 0);
    lastHackSuccess = success;

    if(success) { playSfx(sfxSuccess); runSuccessCount++; }
    else { playSfx(sfxFail); }

    runScoreTotal += lastHackScore;
    state = STATE.RESULT;
    syncMusicToState();
  }

  function nextHackOrEnd(){
    if(runIndex + 1 < optSeries){
      startHackAtIndex(runIndex + 1);
    } else {
      state = STATE.MENU;
      status = `Série terminée : ${runSuccessCount}/${optSeries} réussites | Score total : ${runScoreTotal}`;
      syncMusicToState();
    }
  }

  function pathColor(key){
    if(key==="P1") return COL.pathRed;
    if(key==="P2") return COL.pathBlue;
    if(key==="P12") return COL.pathGreen;
    if(key==="P2ONLY") return COL.pathBlue;
    if(key.startsWith("EXTRA")){
      const idx = parseInt(key.replace("EXTRA",""),10)-1;
      return COL.extras[idx] || COL.cyan;
    }
    return COL.cyan;
  }

  // =========================================================
  // INPUT (AZERTY + QWERTY) + Easter egg "="
  // =========================================================
  window.addEventListener("keydown", (e) => {
    unlockAudioOnce();

    // Easter egg routes toggle: "=" or "+" etc
    if(state === STATE.PLAY){
      if (e.code === "Equal" || e.key === "=" || e.key === "+" || e.key === ")") {
        showPaths = !showPaths;
        playClick(); // tiny feedback
        return;
      }
    }

    if(state === STATE.MENU){
      const k = e.key.toLowerCase();
      let changed = false;

      // Naviguer options
      if(e.key === "ArrowLeft" || k === "q" || k === "a") { optDiff = clamp(optDiff - 1, 5, 15); changed = true; }
      if(e.key === "ArrowRight" || k === "d") { optDiff = clamp(optDiff + 1, 5, 15); changed = true; }

      // Série : haut/bas
      if(e.key === "ArrowUp" || k === "z" || k === "w") { optSeries = clamp(optSeries + 1, 1, 20); changed = true; }
      if(e.key === "ArrowDown" || k === "s") { optSeries = clamp(optSeries - 1, 1, 20); changed = true; }

      // Temps : PageUp/PageDown ou +/- (pratique)
      if(e.key === "PageUp" || e.key === "+") { optTimeLimit = clamp(optTimeLimit + 1, 3, 60); changed = true; }
      if(e.key === "PageDown" || e.key === "-") { optTimeLimit = clamp(optTimeLimit - 1, 3, 60); changed = true; }

      // Bonus/malus : B
      if(k === "b"){
        optBonusMode = (optBonusMode === "none") ? "bonus" : (optBonusMode === "bonus") ? "malus" : "none";
        changed = true;
      }

      // NEW: Undo toggle : U
      if(k === "u"){
        optUndoAllowed = !optUndoAllowed;
        changed = true;
      }

      // Seed random : R
      if(k === "r"){
        optSeedText = randomSeedText();
        changed = true;
      }

      // Coller seed complète : V (ouvre prompt)
      if(k === "v"){
        const pasted = prompt("Colle une seed complète (BP2....) puis OK :");
        if(pasted && applySeedString(pasted.trim())){
          status = "Seed appliquée.";
          playClick();
        } else if(pasted) {
          status = "Seed invalide.";
          playClick();
        }
      }

      // Copier seed : C
      if(k === "c"){
        updateShareSeed();
        navigator.clipboard?.writeText(shareSeed).then(()=>{
          status = "Seed copiée dans le presse-papiers.";
          playClick();
        }).catch(()=>{
          status = "Copie impossible (navigateur).";
          playClick();
        });
      }

      // Lancer : Entrée
      if(e.key === "Enter"){
        updateShareSeed();
        playClick();
        startRun();
      }

      if(changed){
        playClick();
        updateShareSeed();
      }
      syncMusicToState();
      return;
    }

    if(state === STATE.PLAY){
      const n = s.grid;
      let [r,c]=cursor;
      const k = e.key.toLowerCase();

      if(e.key==="Escape"){ playClick(); state=STATE.MENU; syncMusicToState(); return; }
      if(e.key==="Backspace"){ e.preventDefault(); undo(); return; }
      if(e.key==="Enter"){ pick(r,c); return; }

      // Movement (silent) – or enable click if you want
      if(e.key==="ArrowUp" || k==="z" || k==="w") r=clamp(r-1,0,n-1);
      else if(e.key==="ArrowDown" || k==="s") r=clamp(r+1,0,n-1);
      else if(e.key==="ArrowLeft" || k==="q" || k==="a") c=clamp(c-1,0,n-1);
      else if(e.key==="ArrowRight" || k==="d") c=clamp(c+1,0,n-1);

      cursor=[r,c];
      return;
    }

    if(state === STATE.RESULT){
      if(e.key === "Escape"){ playClick(); state=STATE.MENU; syncMusicToState(); return; }
      if(e.key === "Enter"){ playClick(); nextHackOrEnd(); return; }
    }
  });

  canvas.addEventListener("mousedown", (e) => {
    unlockAudioOnce();
    if(state!==STATE.PLAY) return;

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX-rect.left;
    const my = e.clientY-rect.top;

    const layout = computeLayout(window.innerWidth, window.innerHeight, s.grid);
    const hit = hitCell(mx,my,s.grid,layout.origin,layout.cell,layout.gap);
    if(hit){
      cursor=hit;
      pick(hit[0],hit[1]); // pick already plays click sound
    }
  });

  // =========================================================
  // RENDER
  // =========================================================
  function drawBackground(w,h){
    const g = ctx.createLinearGradient(0,0,w,h);
    g.addColorStop(0, rgb(COL.bg1));
    g.addColorStop(1, rgb(COL.bg0));
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // Optional animated menu bg frames (behind UI)
    drawMenuBackgroundFrames(w,h);

    // neon accent bar
    ctx.fillStyle = "rgba(0,255,160,0.06)";
    ctx.fillRect(0,0,w,64);

    drawScanlines(w,h);
    drawGrain(w,h);
  }

  function draw(){
    const w = window.innerWidth, h = window.innerHeight;
    ctx.clearRect(0,0,w,h);
    drawBackground(w,h);

    neonText("BREACH PROTOCOL", 16, 16, COL.green, 34, "left");

    if(state === STATE.MENU){
      syncMusicToState();

      ctx.font = "18px Consolas, monospace";
      ctx.fillStyle = rgb(COL.dim);
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText(status || "Menu : configure la session.", 16, 60);

      const panel = {x: 150, y: 100, w: w-300, h: h-200};
      fillPanel(panel, COL.panel, COL.green);

      neonText("PARAMÈTRES DE SESSION", panel.x + panel.w/2, panel.y + 26, COL.cyan, 26, "center");

      ctx.font = "20px Consolas, monospace";
      ctx.fillStyle = rgb(COL.text);
      ctx.textAlign = "left";

      let y = panel.y + 90;
      const xL = panel.x + 34;

      // NOTE: you said you manually moved xL+240 -> xL+275 in V3-Fix.
      // Keep it if you like; here we use +275 to match your V3-Fix.
      const xV = xL + 275;

      ctx.fillStyle = rgb(COL.cyan);
      ctx.fillText("Difficulté", xL, y);
      ctx.fillStyle = rgb(COL.text);
      ctx.fillText(String(optDiff), xV, y); y += 34;

      ctx.fillStyle = rgb(COL.cyan);
      ctx.fillText("Série (nombre de hacks)", xL, y);
      ctx.fillStyle = rgb(COL.text);
      ctx.fillText(String(optSeries), xV, y); y += 34;

      ctx.fillStyle = rgb(COL.cyan);
      ctx.fillText("Temps par sélection (s)", xL, y);
      ctx.fillStyle = rgb(COL.text);
      ctx.fillText(String(optTimeLimit), xV, y); y += 34;

      ctx.fillStyle = rgb(COL.cyan);
      ctx.fillText("Bonus / Malus", xL, y);
      ctx.fillStyle = rgb(COL.text);
      ctx.fillText(BONUS_LABELS[optBonusMode], xV, y); y += 34;

      // NEW: Undo option row
      ctx.fillStyle = rgb(COL.cyan);
      ctx.fillText("Retour arrière", xL, y);
      ctx.fillStyle = rgb(COL.text);
      ctx.fillText(optUndoAllowed ? "Autorisé" : "Désactivé", xV, y); y += 44;

      // Seed block
      ctx.fillStyle = rgb(COL.cyan);
      ctx.fillText("Seed partagée", xL, y); y += 26;

      const box = {x:xL, y:y, w: panel.w - 68, h: 84};
      fillPanel(box, COL.panel2, COL.cyan);

      ctx.font = "16px Consolas, monospace";
      ctx.fillStyle = rgb(COL.text);
      ctx.textAlign = "left";
      ctx.fillText("Seed courte : " + optSeedText, box.x + 14, box.y + 14);
      ctx.fillStyle = rgb(COL.dim);
      ctx.fillText("Seed complète : " + shareSeed, box.x + 14, box.y + 40);

      y += 110;

      // Controls panel
      ctx.font = "16px Consolas, monospace";
      ctx.fillStyle = rgb(COL.dim);
      ctx.fillText("Contrôles (menu)", xL, y); y += 22;
      ctx.fillText("← → (ou Q/D/A) : difficulté | ↑ ↓ : série | PageUp/PageDown ou +/- : temps", xL, y); y += 20;
      ctx.fillText("B : bonus/malus | U : retour arrière ON/OFF | R : seed aléatoire", xL, y); y += 20;
      ctx.fillText("V : coller seed complète | C : copier seed | Entrée : démarrer la série", xL, y); y += 20;

      return;
    }

    if(state === STATE.PLAY){
      syncMusicToState();

      const layout = computeLayout(w,h,s.grid);

      fillPanel(layout.gridPanel, COL.panel, COL.green);
      fillPanel(layout.rightPanel, COL.panel, COL.cyan);

      const now = performance.now()/1000;
      const timeLimit = effectiveTimeLimit();
      const remaining = Math.max(0, timeLimit - (now - stepTimerStart));
      const timerCol = remaining>3 ? COL.yellow : COL.red;

      // Top HUD
      ctx.textAlign="left"; ctx.textBaseline="top";
      ctx.font="18px Consolas, monospace";
      ctx.fillStyle=rgb(COL.dim);
      ctx.fillText(
        `Série : ${runIndex+1}/${optSeries} | Difficulté ${optDiff} | Scénario : ${SCEN_LABELS[scenarioId]}`,
        16, 60
      );

      ctx.font="700 32px Consolas, monospace";
      ctx.fillStyle=rgb(timerCol);
      ctx.textAlign="right";
      ctx.fillText(`TIMER: ${remaining.toFixed(1)}s`, w-16, 16);

      // Buffer & status
      ctx.textAlign="left";
      ctx.font="20px Consolas, monospace";
      ctx.fillStyle=rgb(COL.cyan);
      ctx.fillText("BUFFER", layout.gridPanel.x+16, layout.gridPanel.y+14);

      ctx.font="18px Consolas, monospace";
      ctx.fillStyle=rgb(COL.text);
      ctx.fillText(buffer.length ? buffer.join(" ") : "<vide>", layout.gridPanel.x+16, layout.gridPanel.y+42);

      ctx.fillStyle=rgb(status.toLowerCase().includes("interdit") ? COL.red : COL.dim);
      ctx.fillText(status, layout.gridPanel.x+16, layout.gridPanel.y+66);

      // Allowed set
      const step = chosen.length;
      const last = chosen.length ? chosen[chosen.length-1] : null;
      const allowed = allowedMoves(s.grid, step, last);
      const allowedSet = new Set(allowed.map(p=>p[0]+","+p[1]));
      const chosenSet = new Set(chosen.map(p=>p[0]+","+p[1]));

      // Path sets (easter egg)
      const pathSets = [];
      if(showPaths){
        for(const k in paths){
          const set = new Set(paths[k].map(p=>p[0]+","+p[1]));
          pathSets.push([pathColor(k), set]);
        }
      }

      // Grid title
      ctx.font="20px Consolas, monospace";
      ctx.fillStyle=rgb(COL.green);
      ctx.fillText("CODE MATRIX", layout.gridPanel.x+16, layout.gridPanel.y+94);

      // Draw grid
      for(let r=0;r<s.grid;r++){
        for(let c=0;c<s.grid;c++){
          const rect = cellRect(layout.origin, layout.cell, layout.gap, r,c);

          ctx.fillStyle=rgb(COL.cell);
          roundRect(rect.x,rect.y,rect.w,rect.h,10); ctx.fill();

          ctx.strokeStyle=rgba(COL.cellBorder, 0.8);
          ctx.lineWidth=2; ctx.stroke();

          // path overlays
          if(showPaths){
            for(const [col,set] of pathSets){
              if(set.has(r+","+c)){
                ctx.strokeStyle=rgba(col, 0.9);
                ctx.lineWidth=2;
                roundRect(rect.x-2,rect.y-2,rect.w+4,rect.h+4,12);
                ctx.stroke();
              }
            }
          }

          // allowed outline
          if(allowedSet.has(r+","+c)){
            ctx.strokeStyle=rgba(COL.cyan, 0.9);
            ctx.lineWidth=3;
            roundRect(rect.x-4,rect.y-4,rect.w+8,rect.h+8,14);
            ctx.stroke();
          }

          // chosen
          if(chosenSet.has(r+","+c)){
            ctx.fillStyle="rgba(35,18,45,0.95)";
            roundRect(rect.x,rect.y,rect.w,rect.h,10); ctx.fill();
            ctx.strokeStyle=rgba(COL.magenta, 0.9);
            ctx.lineWidth=3; ctx.stroke();
          }

          // cursor
          if(cursor[0]===r && cursor[1]===c){
            ctx.strokeStyle=rgba(COL.yellow, 0.9);
            ctx.lineWidth=3;
            roundRect(rect.x-6,rect.y-6,rect.w+12,rect.h+12,16);
            ctx.stroke();
          }

          // token text
          ctx.fillStyle=rgb(COL.text);
          ctx.textAlign="center"; ctx.textBaseline="middle";
          ctx.font="18px Consolas, monospace";
          ctx.fillText(grid[r][c], rect.x+rect.w/2, rect.y+rect.h/2);
        }
      }

      // Right panel puzzles
      ctx.textAlign="left"; ctx.textBaseline="top";
      ctx.font="20px Consolas, monospace";
      ctx.fillStyle=rgb(COL.green);
      ctx.fillText("PUZZLES À UPLOAD", layout.rightPanel.x+16, layout.rightPanel.y+16);

      const res = scoreAndDone(buffer, puzzles);
      ctx.font="18px Consolas, monospace";
      ctx.fillStyle=rgb(COL.dim);
      const doneTxt = res.done.length ? res.done.map(i=>"P"+(i+1)).join(", ") : "aucun";
      ctx.fillText(`Score : ${res.score} | Validés : ${doneTxt}`, layout.rightPanel.x+16, layout.rightPanel.y+44);

      let y = layout.rightPanel.y+78;
      puzzles.forEach((seq,i)=>{
        const isDone = bufferContains(buffer, seq);
        ctx.fillStyle=rgb(isDone ? COL.magenta : COL.text);
        const prefix = isDone ? "✓" : "•";
        ctx.fillText(`${prefix} Puzzle ${i+1}: ${seq.join(" ")}`, layout.rightPanel.x+16, y);
        y += 28;
      });

      // Seed mini display
      y += 10;
      ctx.fillStyle=rgb(COL.cyan);
      ctx.fillText("Seed", layout.rightPanel.x+16, y); y += 22;
      ctx.fillStyle=rgb(COL.dim);
      ctx.font="14px Consolas, monospace";
      ctx.fillText(shareSeed, layout.rightPanel.x+16, y); y += 26;

      // Routes legend (sans mention de touche)
      ctx.font="18px Consolas, monospace";
      ctx.fillStyle=rgb(COL.cyan);
      ctx.fillText("Routes", layout.rightPanel.x+16, y); y += 24;

      const legend = [];
      if(paths.P1) legend.push(["Chemin P1", COL.pathRed]);
      if(paths.P12) legend.push(["Chemin P1+P2", COL.pathGreen]);
      if(paths.P2) legend.push(["Chemin P2", COL.pathBlue]);
      if(paths.P2ONLY) legend.push(["Chemin P2 (sans P1)", COL.pathBlue]);
      Object.keys(paths).filter(k=>k.startsWith("EXTRA")).sort().forEach(k=>{
        legend.push(["Chemin "+k, pathColor(k)]);
      });

      ctx.font="16px Consolas, monospace";
      legend.slice(0,10).forEach(([name,col])=>{
        ctx.fillStyle=rgb(col);
        ctx.fillText("■ "+name, layout.rightPanel.x+16, y);
        y += 20;
      });

      // timer check
      if(remaining <= 0){
        status = "Temps écoulé — transfert interrompu.";
        finishHack(true);
      }
      return;
    }

    if(state === STATE.RESULT){
      syncMusicToState();

      const res = scoreAndDone(buffer, puzzles);
      const ok = lastHackSuccess;

      neonText(ok ? "TRANSFERT RÉUSSI" : "TRANSFERT ÉCHOUÉ", w/2, 140, ok ? COL.green : COL.red, 42, "center");

      ctx.font="20px Consolas, monospace";
      ctx.fillStyle=rgb(COL.dim);
      ctx.textAlign="center"; ctx.textBaseline="top";
      ctx.fillText(`Hack ${runIndex+1}/${optSeries} — Score : ${res.score} — Total : ${runScoreTotal}`, w/2, 210);

      const doneTxt = res.done.length ? res.done.map(i=>"Puzzle "+(i+1)).join(", ") : "aucun";
      ctx.fillText("Validés : " + doneTxt, w/2, 250);

      ctx.fillStyle=rgb(COL.dim);
      ctx.fillText("Entrée : hack suivant | ESC : menu", w/2, 320);

      return;
    }
  }

  // =========================================================
  // LOOP
  // =========================================================
  function loop(){
    draw();
    requestAnimationFrame(loop);
  }

  // init
  updateShareSeed();
  syncMusicToState();
  loop();

})();
</script>
</body>
</html>

